<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Study: Garbage Collection - Joker1092 Portfolio</title>
    <link rel="stylesheet" href="style.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <style>
        .project-detail {
            padding: 4rem 2rem;
            max-width: 900px;
            margin: 0 auto;
            text-align: left;
        }
        .project-detail h1 {
            font-size: 3rem;
            color: var(--primary-color);
            margin-bottom: 1rem;
            text-align: center;
        }
        .project-detail .meta-info {
            text-align: center;
            margin-bottom: 3rem;
            font-style: italic;
            color: #aaa;
        }
        .project-detail h3 {
            font-size: 1.8rem;
            color: var(--primary-color);
            margin-top: 3rem;
            margin-bottom: 1rem;
            border-left: 4px solid var(--primary-color);
            padding-left: 1rem;
        }
        .project-detail p, .project-detail ul {
            margin-bottom: 1.5rem;
            line-height: 1.8;
        }
        .project-detail ul {
            list-style-position: inside;
            padding-left: 1rem;
        }
        .back-link-wrapper {
            text-align: center;
            margin-top: 4rem;
        }
        .back-link {
            display: inline-block;
            padding: 0.8rem 2rem;
            border: 2px solid var(--primary-color);
            border-radius: 50px;
            color: var(--primary-color);
            text-decoration: none;
            font-weight: bold;
            transition: all 0.3s ease;
        }
        .back-link:hover {
            background-color: var(--primary-color);
            color: var(--background-color);
        }
        pre code {
            border-radius: 8px;
            font-size: 0.9rem;
            line-height: 1.5;
        }
    </style>
</head>
<body>
    <header>
        <nav>
            <div class="logo">PORTFOLIO</div>
            <ul>
                <li><a href="index.html#about">About</a></li>
                <li><a href="index.html#projects">Projects</a></li>
                <li><a href="index.html#skills">Skills</a></li>
                <li><a href="index.html#studies">Studies</a></li>
                <li><a href="index.html#contact">Contact</a></li>
            </ul>
        </nav>
    </header>

    <main>
        <article class="project-detail">
            <h1>연구 노트: 가비지 컬렉션 (Garbage Collection)</h1>
            <p class="meta-info">주제: Memory Management | 관련 기술: GC, C#, Java, Runtime System</p>

            <h3>연구 계기</h3>
            <p>
                C++과 같은 언어에서는 프로그래머가 직접 메모리를 할당(`new`)하고 해제(`delete`)해야 합니다.  
                하지만 이 과정에서 메모리 누수나 해제 후 접근과 같은 오류가 자주 발생합니다.  
                이런 문제를 자동으로 해결하기 위한 기술이 바로 <strong>가비지 컬렉션(Garbage Collection)</strong>입니다.  
                이번 연구에서는 다양한 언어(C#, Java, Python 등)에서 사용되는 GC의 동작 원리를 이해하고,  
                수동 메모리 관리 방식과 비교하여 각각의 장단점을 분석했습니다.
            </p>

            <h3>핵심 원리</h3>
            <p>
                가비지 컬렉션은 프로그램 실행 중 더 이상 사용되지 않는 객체를 자동으로 탐지하고 회수하는 시스템입니다.  
                대부분의 GC는 <strong>Mark and Sweep</strong> 알고리즘을 기반으로 동작하며, 다음 두 단계를 거칩니다.
            </p>
            <ul>
                <li><b>Mark 단계:</b> 루트 객체(스택 변수, 전역 변수 등)에서 접근 가능한 모든 객체를 “도달 가능(reachable)”로 표시합니다.</li>
                <li><b>Sweep 단계:</b> 표시되지 않은 객체를 메모리에서 해제합니다.</li>
            </ul>

            <p>
                하지만 모든 객체를 매번 검사하는 것은 비효율적이므로,  
                현대적인 GC는 <strong>세대별 수집(Generational Collection)</strong> 기법을 사용합니다.  
                이는 객체의 생존 시간을 기반으로 세대를 나누어,  
                짧은 생명 주기를 가진 객체를 더 자주 검사함으로써 성능을 개선하는 방식입니다.
            </p>

            <pre><code class="language-cpp">// 의사 코드: Mark and Sweep 알고리즘 예시
function GarbageCollect() {
    // 1. Mark 단계
    for (object in heap)
        if (isReachable(object))
            object.marked = true;

    // 2. Sweep 단계
    for (object in heap)
        if (!object.marked)
            free(object);
}
</code></pre>

            <p>
                실제 언어별 구현 예시는 다르지만, 기본 개념은 동일합니다.  
                Java의 JVM, C#의 CLR, Python의 참조 카운팅(reference counting) 모두  
                “더 이상 사용되지 않는 객체를 안전하게 회수한다”는 동일한 목표를 가집니다.
            </p>

            <h3>가비지 컬렉션과 수동 메모리 관리의 비교</h3>
            <ul>
                <li><b>GC의 장점:</b> 메모리 누수 방지, 코드 안정성 향상, 생산성 증가</li>
                <li><b>GC의 단점:</b> 런타임 중 예상치 못한 성능 정지(Pause), 실시간 시스템에 부적합</li>
                <li><b>수동 관리의 장점:</b> 메모리 제어력 극대화, 실시간 처리에 유리</li>
                <li><b>수동 관리의 단점:</b> 코드 복잡도 증가, 해제 누락 및 이중 해제 위험</li>
            </ul>

            <h3>결론 및 배운 점</h3>
            <p>
                가비지 컬렉션의 원리를 학습하면서,  
                언어 설계 철학에 따라 메모리 관리 방식이 얼마나 달라질 수 있는지 깨달았습니다.  
                C++의 수동 관리 방식은 세밀한 제어와 성능을 제공하지만,  
                GC를 사용하는 언어들은 안전성과 개발 생산성을 극대화합니다.  
                실제 프로젝트에서는 두 접근 방식을 적절히 이해하고 상황에 맞게 선택하는 것이 중요하다는 점을 배웠습니다.
            </p>

            <div class="back-link-wrapper">
                <a href="index.html#studies" class="back-link">&larr; 연구 목록으로 돌아가기</a>
            </div>
        </article>
    </main>

    <footer>
        <p>&copy; 2025 Woo Secheol. All Rights Reserved.</p>
    </footer>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
</body>
</html>
